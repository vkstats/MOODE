#' Searching for a multi-objective optimal completely randomised design.
#' @description Performing search for a (nearly) optimum factorial design, oprimising with respect to a specified compound criterion.
#' 
#' @param mood.object The object generated by `mood` function, containing the parameters of the experiment, the compound criterion and search parameters 
#' @param pointex Parameter specifying the search algorithm. If `TRUE`, the point-exchange algorithm is used, and if `FALSE` -- the coordinate-exchange
#' @param update.info If `TRUE`, progress messages through the search iterations are shown.
#' @export
#' @details `Search` takes the mood object as an input with all the parameters of the experiment. Runs a point-exchange or a coordinate-exchange algorithm, returns design and model matrices, computation time and criteria values.
#' 
#' @return List of the outputs generated by the search:
#' \itemize{
#' \item `X.design` Design matrix.
#' \item `df` The number of pure error degrees of freedom.
#' \item `X1` Primary model matrix for the found (nearly-) optimum design.
#' \item `X2` Model matrix of potential terms for the found (nearly-) optimum design.  
#' \item `compound.value` The compound criterion value of the (nearly-) optimum design.
#' \item `criteria.values` Component criteria values of the (nearly-) optimum design.
#' \item `path` The "path" of compound criterion values of the optimum designs obtained after for each random start.
#' \item `time` Computation time. 
#' }
#' 
#' @seealso [mood]
#' @examples
#' 
#'example1 <- mood(K = 5, Klev = 3, Nruns = 40, criterion.choice = "GDP", 
#'                 kappa.Ds = 1./3, kappa.DP = 1./3, kappa.LoF = 1./3, 
#'                 Nstarts = 50, tau2 = 0.1, primary.model = "second_order",
#'                 potential.model = NA, 
#'                 potential.terms = c("x12x2", "x22x3", "x32x4", "x42x5"))
#'example1
#'
#'Search_point <- Search(example1, pointex = TRUE)
#'Search_point
#'Search_coord <- Search(example1, pointex = FALSE)
#'Search_coord

Search <- function(mood.object, pointex = TRUE, update.info = TRUE)
{
  K <- mood.object$K
  Levels <- mood.object$Levels
  Klev <- mood.object$Klev
  
  P <- mood.object$P
  Q <- mood.object$Q
  primary.terms <- mood.object$primary.terms
  potential.terms <- mood.object$potential.terms
  
  Nruns <- mood.object$Nruns
  Nstarts <- mood.object$Nstarts
  Biter <- mood.object$Biter
  
  W <- mood.object$W; Z0 <- mood.object$Z0
  tau2 <- mood.object$tau2; tau <- mood.object$tau
  
  criterion.choice <- mood.object$criterion.choice
  Cubic <- mood.object$Cubic
  orth<- mood.object$orth
  
  kappa.Ls <- mood.object$kappa.Ls
  kappa.LP <- mood.object$kappa.LP
  kappa.Ds <- mood.object$kappa.Ds
  kappa.DP <- mood.object$kappa.DP
  kappa.LoF <- mood.object$kappa.LoF
  kappa.bias <- mood.object$kappa.bias
  kappa.mse <- mood.object$kappa.mse
  
  alpha.DP <- mood.object$alpha.DP
  alpha.LP <- mood.object$alpha.LP
  alpha.LoF <- mood.object$alpha.LoF
  alpha.LoFL <- mood.object$alpha.LoFL
  
  search.object <- list("Nruns" = Nruns, "P" = P, "Q" = Q,
                        "criterion.choice" = criterion.choice,
                        "primary.terms" = primary.terms,
                        "potential.terms" = potential.terms,
                        "Biter" = Biter, "tau2" = tau2,"tau" = tau, 
                        "W" = W, "Z0" = Z0,
                        "alpha.DP" = alpha.DP,"alpha.LP" = alpha.LP,
                        "alpha.LoF" = alpha.LoF, "alpha.LoFL" = alpha.LoFL,
                        "kappa.Ds" = kappa.Ds, "kappa.DP" = kappa.DP,
                        "kappa.Ls" = kappa.Ls, "kappa.LP" = kappa.LP,
                        "kappa.LoF" = kappa.LoF, "kappa.bias" = kappa.bias, 
                        "kappa.mse" = kappa.mse)
  
  start_time <- Sys.time()
  
  cand.trt <- candidate_trt_set(Levels, K, Cubic)   # form the candidate set of treatments
  cand.full <- candidate_set_full(cand.trt, K)      # build candidate set, with potential terms
  
  if (orth){
    cand.full <- candidate_set_orth(cand.full,
                                    primary.terms, potential.terms)
    print("Point exchange algorithm will be  used for othonormalised candidate sets")
  }

  crit.values<-matrix(0,ncol=1, nrow=Nstarts)
  for (k in 1:Nstarts){
    
    if (update.info){
      print(sprintf("Current iteration: %i out of %i", k, Nstarts))
    }
    
    initial <- initial.full(cand.full, Nruns, primary.terms, potential.terms)
    X1 <- initial$X1
    X2 <- initial$X2
    
    if (k==1){
      crit.opt <- objfun(X1, X2, search.object)$compound
      X1.opt <- X1; X2.opt <- X2
    }
    s <- 1
    while (s==1)
    {
      if(pointex) {
        Xs <- point.swap(X1, X2, cand.full, search.object)
      } else {
        #Xs <- coord.swap(X1, X2, K, Levels, search.object)
        Xs <- coord.swap.same(X1, X2, K, Levels, search.object)
      }
      X1 <- Xs$X1; X2 <- Xs$X2;
      s <- Xs$search
    }
    crit.values[k] <- Xs$compound # track the change of criterion values
    if (crit.opt > Xs$compound)
    {
      X1.opt <- Xs$X1; X2.opt<-Xs$X2
      crit.opt <- Xs$compound
    }
  }
  finish_time <- Sys.time()
  time <- finish_time - start_time

  criteria.opt <- objfun(X1, X2, search.object)
  X.design <- X1.opt[,2:(K+1)]
  
  list (X.design = X.design, df=criteria.opt$df, 
        X1=X1.opt, X2=X2.opt, 
        compound.value = criteria.opt$compound, 
        criteria.values= criteria.opt, path = crit.values,
        time=time)
}
